# File: home-manager-modules/xdg.nix
#
# Purpose: Configures XDG MIME type associations based on application definitions
#          in applications.nix where desktopFile.isDefaultHandler = true.
#          Asserts that necessary .desktop file names are provided.
#
# Depends on: config.applications (specifically the camelCase options), lib
# Used by:   Home Manager's xdg.mimeApps module
# Creates:   Entries in ~/.config/mimeapps.list (indirectly via xdg.mimeApps)
#
{
  config,
  lib,
  ...
}: let
  # --- Flatten the nested application structure from config.applications ---
  # Creates a flat list of objects, each containing workspaceName, appName (logical key),
  # and the actual app configuration attribute set ('value').
  allAppsWithInfo = lib.flatten (lib.mapAttrsToList ( # Renamed: allAppsWithInfo
      wsName: wsConfig:
      # Renamed: ws_name -> wsName, ws_config -> wsConfig
        lib.mapAttrsToList (appKey: appConfig: {
          # Renamed: app_key -> appKey, app_config -> appConfig
          appName = appKey;
          workspaceName = wsName;
          value = appConfig; # The app's configuration attribute set
        }) (
          # Ensure the workspace config has an 'apps' attribute set before trying to iterate it
          if wsConfig ? "apps" && lib.isAttrs wsConfig.apps
          then wsConfig.apps
          else {} # Return empty set if 'apps' is missing or not an attrset
        )
    )
    config.applications); # Assumes top-level option is still 'applications'

  # --- Function to generate the defaultApplications attribute set for xdg.mimeApps ---
  # Iterates through the flattened list of apps and constructs the map:
  # { "mime/type" = [ "app.desktop" ]; ... }
  generateDefaultApps = appsInfoList:
  # Renamed: generateDefaultApps, appsInfoList
    lib.foldl' ( # Use foldl' for potentially large lists
      acc: appInfoItem: let
        # Renamed: appInfo -> appInfoItem
        # Extract the actual application configuration attrset
        appConfig = appInfoItem.value; # Renamed: app -> appConfig
        # Access the desktopFile submodule config. Relies on the option default to provide an empty attrset if not explicitly configured.
        # No 'or {}' needed - accessing non-existent keys on this will return null, handled below.
        desktopConfig = appConfig.desktopFile; # Renamed: desktopCfg -> desktopConfig
        # Construct a unique identifier for error messages
        appNameForMsg = "${appInfoItem.workspaceName}.${appInfoItem.appName}"; # Renamed: appNameForMsg

        # --- Determine if this app should be a default handler ---
        # Checks if required attributes are present, correctly typed, and set to true/non-empty.
        isValidForAssociation =
          # Renamed: isValidForAssociation
          desktopConfig
          ? "defaultAssociations" # Use camelCase
          && lib.isList desktopConfig.defaultAssociations
          && desktopConfig.defaultAssociations != []
          && desktopConfig ? "isDefaultHandler" # Use camelCase
          && desktopConfig.isDefaultHandler; # Explicitly check boolean value

        # --- Determine the target .desktop file name ---
        # This logic runs ONLY if isValidForAssociation is true.
        # It throws a configuration error if the required desktop filename info is missing.
        targetDesktopFile =
          # Renamed: targetDesktopFile
          if isValidForAssociation
          then # Proceed only if association basics are met
            # Case 1: Desktop file is GENERATED by desktop-entries.nix
            if desktopConfig ? "generate" && desktopConfig.generate
            then
              # Check if desktopName is present and valid for generated files
              if !(desktopConfig ? "desktopName" && lib.isString desktopConfig.desktopName && desktopConfig.desktopName != "") # Use camelCase
              then
                # Required info missing: throw a configuration error, failing the build.
                throw "Error [xdg.nix]: App '${appNameForMsg}' has 'isDefaultHandler=true' and 'generate=true' but is missing a valid 'desktopName'. Cannot associate."
              else
                # Required info present: construct the expected filename.
                "${desktopConfig.desktopName}.desktop" # Use camelCase
            # Case 2: Desktop file is NOT generated; uses an existing file
            else
              # Check if targetDesktopFilename is present and valid for existing files
              if !(desktopConfig ? "targetDesktopFilename" && lib.isString desktopConfig.targetDesktopFilename && desktopConfig.targetDesktopFilename != "") # Use camelCase
              then
                # Required info missing: throw a configuration error.
                throw "Error [xdg.nix]: App '${appNameForMsg}' has 'isDefaultHandler=true' and 'generate=false' but is missing a valid 'targetDesktopFilename'. Cannot associate."
              else
                # Required info present: use the provided filename directly.
                desktopConfig.targetDesktopFilename # Use camelCase
          else
            # App is not configured as a default handler (isValidForAssociation is false).
            # Return null signifies no target file needed for this app in this context.
            null;
      in
        # --- Add associations to the accumulator ---
        # Only proceed if the app is valid for association AND we successfully determined
        # a target desktop file (meaning no error was thrown above).
        if isValidForAssociation && targetDesktopFile != null
        then
          # Fold over the list of MIME types for this app
          lib.foldl' (
            innerAcc: mimeType:
            # Renamed: innerAcc, mimeType
            # Merge the new association into the accumulator.
            # Ensures that each mimeType maps to a list containing the targetDesktopFile.
            # Note: This currently overwrites associations for a MIME type if multiple apps declare it.
            # Consider using lib.mergeAttrsWith or similar if merging lists per MIME type is desired.
              innerAcc // {"${mimeType}" = [targetDesktopFile];}
          )
          acc # Start inner fold with the current accumulator
          
          desktopConfig.defaultAssociations # Use camelCase
        else
          # Skip this app (not a default handler or required info was missing resulting in targetDesktopFile being null)
          acc # Return the accumulator unchanged
    )
    {} # Start outer fold with an empty attribute set for the final result
    
    appsInfoList; # Process the flattened list of all apps
in {
  # --- Configure xdg.mimeApps ---
  xdg = {
    enable = true;
    mimeApps = {
      # Enable the Home Manager xdg.mimeApps module
      enable = true;
      # Assign the generated map of { "mime/type" = [ "app.desktop" ]; ... }
      defaultApplications = generateDefaultApps allAppsWithInfo; # Use renamed function and variable

      # --- Example Manual Additions ---
      # These could also be defined via applications.nix if preferred,
      # by creating entries with isDefaultHandler=true and the appropriate targetDesktopFilename.
      # Home Manager merges assignments to defaultApplications.
      # defaultApplications."x-scheme-handler/http" = [ "com.brave.Browser.desktop" ];
      # defaultApplications."x-scheme-handler/https" = [ "com.brave.Browser.desktop" ];
      # defaultApplications."text/html" = [ "com.brave.Browser.desktop" ];
    };
  };
}
