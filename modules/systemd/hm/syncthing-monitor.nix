{pkgs, ...}: let
  # Script to check Syncthing logs and notify on issues
  monitorScript = pkgs.writeShellApplication {
    name = "syncthing-monitor-check";
    runtimeInputs = with pkgs; [
      coreutils # for touch, cat, tail, tr, echo
      gnugrep # for grep
      gnused # for sed
      procps # for pgrep
      systemd # for journalctl
      libnotify # for notify-send
      runtimeShell # The shell itself
    ];
    text = ''
      #!${pkgs.runtimeShell}
      set -euo pipefail

      # --- Configuration ---
      # Keywords indicating potential issues in Syncthing logs
      ERROR_KEYWORDS="error|fail|conflict|insufficient space|stopped|panic"
      # How far back to check the journal (e.g., '1 minute ago', '3 minutes ago')
      SINCE_TIME="2 minutes ago"
      # File to store the last reported log line to avoid spamming for the same repeating error
      # Consider $XDG_CACHE_HOME or $XDG_RUNTIME_DIR for better locations than /tmp
      LAST_ERROR_FILE="/tmp/syncthing_monitor_last_error_''${USER}"
      # Ensure the state file exists
      touch "$LAST_ERROR_FILE"

      # --- Log Check ---
      # Get recent journal entries for the syncthing service matching keywords
      # Assumes the service is named 'syncthing.service' (default for home-manager)
      # Use journalctl from PATH (provided by runtimeInputs)
      # Use grep from PATH (provided by runtimeInputs)
      RECENT_ISSUES=$(journalctl --user -u syncthing.service --since "$SINCE_TIME" --no-pager --output=cat | grep -i -E "$ERROR_KEYWORDS" || true)

      # --- Notification Logic ---
      if [ -n "$RECENT_ISSUES" ]; then
        # Get the very last line reported in this timeframe using tail from PATH
        LAST_LINE=$(echo "$RECENT_ISSUES" | tail -n 1)
        # Read previous line using cat from PATH
        PREVIOUS_LAST_LINE=$(cat "$LAST_ERROR_FILE")

        # Only notify if this specific error line is different from the last one we notified about
        if [ "$LAST_LINE" != "$PREVIOUS_LAST_LINE" ]; then
          echo "Syncthing Monitor: Issue detected - $LAST_LINE" >&2
          # Send notification using notify-send from PATH, use urgency critical
          # DISPLAY and DBUS_SESSION_BUS_ADDRESS should be inherited via systemctl import-environment
          notify-send -u critical --expire-time=15000 "Syncthing Issue" "Detected: $LAST_LINE \n(Check Syncthing UI or journalctl for details)" || echo "Syncthing Monitor: notify-send failed (Check DISPLAY/DBUS vars)" >&2
          # Store this line so we don't spam for it using echo from PATH
          echo "$LAST_LINE" > "$LAST_ERROR_FILE"
        else
           echo "Syncthing Monitor: Issue persists ('$LAST_LINE'), notification already sent." >&2
        fi
      else
        # If no issues found in this run, clear the last error state.
        # This allows notifying again if an old error reappears later.
        echo "" > "$LAST_ERROR_FILE"
        echo "Syncthing Monitor: No recent issues found." >&2
      fi

    ''; # End of script text
  }; # End of writeShellApplication
in {
  # Define the systemd service unit
  systemd.user.services.syncthing-monitor = {
    Unit = {
      Description = "Monitor Syncthing journal for errors";
      # Run after syncthing service itself and graphical session attempted
      After = ["syncthing.service" "graphical-session-pre.target"];
      PartOf = ["graphical-session.target"];
      # Uncomment if you only want this to run *if* syncthing is running
      # Requires = [ "syncthing.service" ];
    };
    Service = {
      Type = "oneshot";
      # Import necessary environment variables from the user session manager
      ExecStartPre = "${pkgs.systemd}/bin/systemctl --user import-environment DISPLAY DBUS_SESSION_BUS_ADDRESS";
      # Run the script generated by writeShellApplication
      ExecStart = "${monitorScript}/bin/syncthing-monitor-check";
      # Log stdout/stderr to the journal for debugging
      StandardOutput = "journal";
      StandardError = "journal";
    };
    # No Install section needed, timer manages activation
  };

  # Define the systemd timer unit
  systemd.user.timers.syncthing-monitor = {
    Unit = {
      Description = "Periodically check Syncthing journal for issues";
    };
    Timer = {
      # Run 3 minutes after user login/boot (allow time for session setup)
      OnBootSec = "3m";
      # Run every 90 seconds thereafter
      OnUnitActiveSec = "90s";
      # Activate the service unit
      Unit = "syncthing-monitor.service";
      # Add some jitter to avoid thundering herd
      RandomizedDelaySec = "10s";
    };
    Install = {
      # Enable the timer automatically
      WantedBy = ["timers.target"];
    };
  };
}
